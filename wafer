import pika
import json
import csv
import os
import sys
from datetime import datetime
import requests
from requests.auth import HTTPBasicAuth

# === è¨­å®šåƒæ•¸ ===
csv_path = r"C:\Users\***\***\***\***\***\lg_list.csv"  # ğŸ‘‰ CSV æª”æ¡ˆè·¯å¾‘
queue_name = "LGE"                # ğŸ‘‰ Queue åç¨±
vhost_name = "APP"                # ğŸ‘‰ RabbitMQ vhost

rabbitmq_host = "***.***.**.***"  # ğŸ‘‰ RabbitMQ ä¼ºæœå™¨ IP / Host
rabbitmq_port = ****              # ğŸ‘‰ AMQP Port
web_port      = ****              # ğŸ‘‰ Management API Port

username = "***"                  # ğŸ‘‰ ä½¿ç”¨è€…åç¨±
password = "***"                  # ğŸ‘‰ ä½¿ç”¨è€…å¯†ç¢¼


# === æª¢æŸ¥ CSV æª”æ¡ˆæ˜¯å¦å­˜åœ¨ï¼Œè‹¥ç„¡å‰‡å»ºç«‹ ===
def ensure_csv_exists():
    if not os.path.exists(csv_path): 
        with open(csv_path, mode='w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(["lotno", "waferid", "customerno", "eventtime", "status"])


# === æª¢æŸ¥ queue æ˜¯å¦ durable ===
def check_queue_durable():
    url = f"http://{rabbitmq_host}:{web_port}/api/queues/{vhost_name}/{queue_name}"
    try:
        res = requests.get(url, auth=HTTPBasicAuth(username, password))
        if res.status_code != 200:
            print(f"âŒ ç„¡æ³•æª¢æŸ¥ queue æ˜¯å¦ durableï¼ˆç‹€æ…‹ç¢¼ {res.status_code}ï¼‰ï¼š{res.text}")
            sys.exit(1)
        data = res.json()
        if data.get("durable") is not True:
            print(f"âŒ Queue '{queue_name}' ä¸æ˜¯ durableï¼Œè«‹é‡æ–°å»ºç«‹æˆ–èª¿æ•´è¨­å®šã€‚")
            sys.exit(1)
        print(f"âœ… Queue '{queue_name}' ç‚º durable")
    except Exception as e:
        print(f"âŒ æª¢æŸ¥ durable æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š{e}")
        sys.exit(1)


# === æ¥æ”¶åˆ°è¨Šæ¯çš„ callback ===
def callback(ch, method, properties, body):
    try:
        message = json.loads(body.decode())
        lotno = message.get("lotno", "")
        waferid = message.get("waferid", "")
        customerno = message.get("customerno", "")
        eventtime = message.get("eventtime", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

        with open(csv_path, mode='a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([lotno, waferid, customerno, eventtime, "PENDING"])

        print(f"âœ… æ–°ä»»å‹™å·²åŠ å…¥ï¼š{waferid} / {lotno}")
        ch.basic_ack(delivery_tag=method.delivery_tag)  # âœ… æ‰‹å‹• ack æˆåŠŸ
    except Exception as e:
        print(f"âŒ è™•ç†è¨Šæ¯æ™‚å‡ºéŒ¯ï¼š{e}")
        # ä¸ ackï¼Œè®“è¨Šæ¯ä¿ç•™åœ¨ queue ä¸­ç­‰å¾…ä¸‹æ¬¡é‡è©¦


# === ä¸»ç¨‹å¼ï¼šå»ºç«‹é€£ç·šã€å•Ÿå‹•ç›£è½ ===
def start_consumer():
    ensure_csv_exists()
    check_queue_durable()

    credentials = pika.PlainCredentials(username, password)
    parameters = pika.ConnectionParameters(
        host=rabbitmq_host,
        port=rabbitmq_port,
        virtual_host=vhost_name,
        credentials=credentials
    )

    connection = pika.BlockingConnection(parameters)
    channel = connection.channel()

    # ä¸é‡æ–°å®£å‘Š queueï¼Œé¿å…åƒæ•¸ä¸ä¸€è‡´å ±éŒ¯
    channel.basic_consume(
        queue=queue_name,
        on_message_callback=callback,
        auto_ack=False  # âœ… æ”¹ç‚ºæ‰‹å‹• ackï¼Œé˜²æ­¢æ‰è³‡æ–™
    )

    print(f"[*] æ­£åœ¨ç›£è½ queue '{queue_name}' çš„ä»»å‹™è¨Šæ¯...ï¼ˆCtrl+C çµæŸï¼‰")
    channel.start_consuming()


if __name__ == "__main__":
    start_consumer()
